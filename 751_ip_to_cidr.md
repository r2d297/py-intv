# IP转CIDR问题解决方案

## 问题理解

给定一个起始IP地址和需要覆盖的地址数量n，要求用最少的CIDR块来精确覆盖[ip, ip+n-1]范围内的所有地址。

LeetCode 751的核心就是你之前问的两个位运算：

start & (-start)：找最大对齐块
1 << (n.bit_length() - 1)：找最大可用块
这正好结合了我们讨论的所有概念：lowbit操作 + CIDR对齐 + 贪心算法！

## 核心思想

使用**贪心算法**：在每一步都选择能使用的最大CIDR块，直到覆盖完所有地址。

LeetCode 751 - IP to CIDR
这是最经典的CIDR题目，核心挑战是：

问题：给定起始IP和数量n，返回最少的CIDR块来覆盖这个范围

算法核心：

贪心策略：每次创建最大可能的CIDR块
两个约束：
对齐约束：start & (-start) - lowbit操作
数量约束：1 << (n.bit_length() - 1) - 你之前问的那个公式！
复杂度：时间O(log n)，空间O(1)

相关题目 45
LeetCode 468 - Validate IP Address：验证IPv4/IPv6格式
LeetCode 93 - Restore IP Addresses：字符串恢复IP地址


## 关键概念

### CIDR块的大小限制
在任何给定位置，CIDR块的最大大小受两个因素制约：

1. **对齐约束**：由于CIDR块必须在2的幂边界上对齐，起始位置的二进制表示决定了最大块大小
2. **数量约束**：不能超过剩余需要覆盖的地址数量

### 对齐约束的计算
关键操作：`start & (-start)`
- 这个位运算返回start中最右边的1位的值
- 表示从当前位置开始能对齐的最大2的幂

**例子**：
- start = 7 (二进制: 111)，7 & (-7) = 1，最大块大小为1
- start = 8 (二进制: 1000)，8 & (-8) = 8，最大块大小为8
- start = 16 (二进制: 10000)，16 & (-16) = 16，最大块大小为16

## 算法步骤

```python
while n > 0:
    # 1. 计算对齐约束
    max_size_by_alignment = start & (-start)  # 如果start != 0
    
    # 2. 考虑数量限制
    block_size = min(max_size_by_alignment, n)
    
    # 3. 计算前缀长度
    # 如果块大小为2^k，则前缀长度为32-k
    prefix_len = 32 - (block_size.bit_length() - 1)
    
    # 4. 生成CIDR块
    result.append(f"{int_to_ip(start)}/{prefix_len}")
    
    # 5. 更新状态
    start += block_size
    n -= block_size
```

## 示例分析

### 示例1：ip="255.0.0.7", n=10

**第一步**：
- 起始：255.0.0.7 (二进制末尾：...00000111)
- 对齐约束：7 & (-7) = 1
- 块大小：min(1, 10) = 1
- CIDR块：255.0.0.7/32 (覆盖1个地址)

**第二步**：
- 起始：255.0.0.8 (二进制末尾：...00001000)
- 对齐约束：8 & (-8) = 8  
- 块大小：min(8, 9) = 8
- CIDR块：255.0.0.8/29 (覆盖8个地址：255.0.0.8-255.0.0.15)

**第三步**：
- 起始：255.0.0.16 (二进制末尾：...00010000)
- 对齐约束：16 & (-16) = 16
- 块大小：min(16, 1) = 1
- CIDR块：255.0.0.16/32 (覆盖1个地址)

**最终结果**：["255.0.0.7/32", "255.0.0.8/29", "255.0.0.16/32"]

## 为什么这个方法最优？

1. **贪心选择性质**：在每个位置选择最大可能的块总是最优的，因为使用更小的块只会增加总的块数量
2. **对齐必要性**：CIDR块必须在2的幂边界对齐，所以不能任意选择起始位置
3. **覆盖完整性**：算法保证精确覆盖指定范围，不多不少

## 复杂度分析

- **时间复杂度**：O(log n) - 最坏情况下需要log n个CIDR块
- **空间复杂度**：O(log n) - 存储结果数组

这种方法高效且optimal，能够用最少的CIDR块覆盖任意给定的IP地址范围。


让我详细解释这个关键的位运算操作 `start & (-start)`：

## 核心概念

`start & (-start)` 返回**能整除start的最大2的幂**，这决定了从当前位置开始能创建的最大CIDR块。

## 二进制原理

### 负数的二进制表示
计算机中负数用**二进制补码**表示：
- `-start = ~start + 1` （按位取反再加1）

### 位运算的魔法
当我们计算 `start & (-start)` 时：
- 这个操作会**保留start中最右边的1位**，其他位都变成0
- 结果就是最右边1位所代表的值

## 具体例子

### 例子1：start = 8
```
start = 8:     00001000
-start = -8:   11111000  (二进制补码)
start & (-start): 00001000 = 8
```
**结果**：8，意味着从位置8开始，可以创建最大8个地址的CIDR块

### 例子2：start = 12  
```
start = 12:    00001100
-start = -12:  11110100  (二进制补码)
start & (-start): 00000100 = 4
```
**结果**：4，意味着从位置12开始，最大只能创建4个地址的CIDR块

### 例子3：start = 7
```
start = 7:     00000111
-start = -7:   11111001  (二进制补码)
start & (-start): 00000001 = 1
```
**结果**：1，意味着从位置7开始，只能创建1个地址的CIDR块

## 为什么这样计算？

### CIDR块的对齐要求
- CIDR块必须在2的幂边界上对齐
- 如果要创建大小为2^k的块，起始地址必须能被2^k整除

### 数学解释
- `start & (-start)` 找到start的**最大2的幂因子**
- 这就是从该位置能创建的最大对齐块大小

## 图解说明

以IP地址的最后8位为例：
```
位置7  (00000111): 最右边的1在第0位 → 最大块大小 = 2^0 = 1
位置8  (00001000): 最右边的1在第3位 → 最大块大小 = 2^3 = 8  
位置12 (00001100): 最右边的1在第2位 → 最大块大小 = 2^2 = 4
位置16 (00010000): 最右边的1在第4位 → 最大块大小 = 2^4 = 16
```

## 实际应用场景

在IP范围 `255.0.0.7` 开始，覆盖10个地址：

1. **位置7**: `7 & (-7) = 1` → 只能用 `/32` (1个地址)
2. **位置8**: `8 & (-8) = 8` → 可以用 `/29` (8个地址)  
3. **位置16**: `16 & (-16) = 16` → 可以用 `/28` (16个地址)，但只需要1个

这个位运算巧妙地利用了二进制的特性，一步就能计算出对齐约束，是这个算法的核心技巧！