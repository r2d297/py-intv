
```
算法巧妙之处
为什么这样能实现"反向深度加权"？

每个整数被累加的次数 = 它出现的轮数到最后一轮的次数
越早出现的整数（深度越浅），被累加越多次
越晚出现的整数（深度越深），被累加越少次
例子 1 验证：

数字 2（深度1）：在第1轮加入 level_sum，被累加2次 → 2×2 = 4
四个 1（深度2）：在第2轮加入 level_sum，被累加1次 → 4×1 = 4
总和：4 + 4 = 8 ✓
例子 2 验证：

数字 1（深度1）：被累加3次 → 1×3 = 3
数字 4（深度2）：被累加2次 → 4×2 = 8
数字 6（深度3）：被累加1次 → 6×1 = 6
总和：3 + 8 + 6 = 17 ✓
这正是"权重 = maxDepth - depth + 1"的巧妙实现！
```