下面用社交信息流/通知系统为例，解释 fanout-on-write 与 fanout-on-read 的概念、优缺点与适用场景。

一、基本概念
- Fanout-on-write（写时扇出）
  - 当作者发一条动态/事件时，立刻“推送/物化”到所有关注者的个人收件箱/时间线存储中（每个 follower 各写一份索引或副本）。
  - 写放大：每次写操作需要对 F 个关注者做 O(F) 次写。
  - 读轻：读取用户时间线时直接按索引分页，延迟低。

- Fanout-on-read（读时扇出）
  - 写入只记录在作者自己的“发件箱”或全局事件流里；当某个用户打开时间线时，临时聚合他所关注的 K 个作者的最新内容并排序返回。
  - 写轻：每次写 O(1)（仅写作者侧或追加到日志）。
  - 读放大：读时对 K 个源做合并/打分（常见为 k-way merge，复杂度与关注数和页大小相关）。

二、优缺点对比（要点）
- 延迟与体验
  - 写时扇出：读延迟低；发布后对大部分粉丝几乎“秒到”。发布高峰会出现写峰值。
  - 读时扇出：发布极快；读延迟较高（每次需要聚合/排序），需要强缓存与预计算才能保证体验。

- 成本与扩展性
  - 写时扇出：存储增加（为每个收件箱存一份索引/指针）；高粉作者会产生写风暴。需消息队列、异步批处理、回压与重试、幂等写。
  - 读时扇出：存储更省；读侧 CPU/IO 压力大，需高效索引、缓存层（Redis）、预聚合与读扩展。

- 一致性与功能
  - 写时扇出：在写入时就能执行隐私/屏蔽/过滤；但后续关系变更（拉黑/取消关注）需要回收或清理已有收件箱中的项目。
  - 读时扇出：可在读时应用最新的关系/隐私规则；但需要每次读都做过滤，计算更重。

三、何时选择哪种
- 小中等关注度场景（绝大多数普通用户）：优先写时扇出，读快、体验好。
- 超高关注度账号（名人/热点源）：优先读时扇出或延迟/限速写时扇出，避免一次写入数百万收件箱。
- 读多写少的业务（典型信息流）：更偏向写时扇出。
- 写多读少/强实时产生但读侧可接受聚合延迟的业务：更偏向读时扇出。

四、常见混合方案（业界主流）
- 分层策略：对“普通作者”用写时扇出；对“名人作者”改为读时聚合，或只推送给“重度互动粉丝”，其余读时拉取。
- 预计算“Feed Head”：后台滚动预聚合每个用户前 N 条，读时直出命中缓存/存储，翻页再走读时合并。
- 冷热分离：热点内容（高权重）写时扇出，长尾内容读时拉取。
- 异步与降级：Kafka/Pulsar 消息 + 多消费组并行 fanout；高峰启用队列限速、部分延迟达。

五、数据模型与实现要点（简述）
- 写时扇出
  - 表/键设计：inbox(user_id, activity_id, score, visibility, dedupe_key, created_at)
  - 流程：producer → queue → fanout workers → 批量写各 follower 的 inbox（Cassandra/DynamoDB/Redis List）
  - 必做：幂等（dedupe_key）、失败重试、回压、批量写、按分片/时间排序键抗热点
- 读时扇出
  - 作者侧 outbox(author_id, activity_id, score, created_at)
  - 读流程：查用户关注列表 K，拉取各 outbox 的头部 M 条，k 路归并排序后截取页大小 P；强依赖缓存与索引
  - 优化：关注列表缓存、合并游标、按时间桶或倒排索引、分层召回 + 重排

六、复杂场景与边界处理
- 删除/编辑回收：写时扇出需要撤回已分发的消息（写 tombstone 或软删）；读时扇出在读时自然过滤。
- 关系变更：拉黑/取消关注的历史内容清理（写时扇出需后台清扫，读时扇出读时过滤）。
- 去重与幂等：以 activity_id 或 (actor_id, object_id, verb) 做幂等键，防止重复投递。
- 新关注者回填：写时扇出需 backfill 历史内容；读时扇出天然能看到历史。
- 排序与推荐：可在写时生成基础 score，读时再融合个性化重排。
- SLA 与一致性：通常最终一致；为“发布后可见”提供软实时目标（如 P95 < 数百毫秒）。

七、复杂度直觉
- 写时扇出：一条动态成本 ~ O(F)，系统总写放大 ~ ΣF（F 为粉丝数）。
- 读时扇出：单次读取成本 ~ O(K log K + data_fetch)，K 为关注数；配合缓存可降到接近 O(P) 的出数。

八、简短伪代码
- Fanout-on-write（消费者）
  - for follower in followers(author):
    - inbox_write(follower, activity, idempotency_key)
- Fanout-on-read（读取）
  - authors = followees(user)
  - heads = fetch_topN_from_outboxes(authors)
  - merged = k_way_merge(heads, by=score/time)
  - return page(merged, size=P)

九、选型建议
- 先以写时扇出为主，配套队列与批量写，满足大多数用户体验
- 为高粉作者启用读时扇出或限速/分批 fanout（混合）
- 用 Redis 缓 feed 头部，Cassandra/DynamoDB 作持久化 inbox/outbox
- 监控分布：关注度长尾、发布峰值、读写比，设定名人阈值与动态切换策略

如你有具体业务规模（DAU、平均关注数、P95 关注数、目标延迟、云上预算），我可以给出更精细的选型与容量估算。